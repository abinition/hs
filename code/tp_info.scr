!+ TP_INFO.SCR
!
! Description:	This script file contains embedded hyperscript functions
!		that perform specific PROMIS transactions for PROMIS
!		operations at Santa Clara
!
!		Each hyperscript function that corresponds to a PROMIS
!		transaction must be enabled in the CONNECT method.
! 
!		Do not add transactions that use PROMIS functions that
!		are not part of MUCHMAIN. (Hyperscript cannot survive
!		between image activations.  You must use a different
!		hyperscript file which activates the appropriate image).
! 
!-
! The following 2 lines ensures that the MUCHMAIN image is activated. 
! (When PROMIS starts up the default image is MEPMAIN)
quit eq view
EXIT
set nopage
!
! Enable HyperScript.  The Hyperscript program will be loaded into 
! memory.  Make sure all TP functions are enabled in the CONNECT method.
##
CONNECT()
{
  enable DISCONNECT ;
  enable ABORT ;
  enable MESSAGE ;

  /* TP methods */
  enable GET_EQPID_STATUS ;
  enable GET_FILE_FIELDS ;
  enable SENDMAIL ;

  /* Enable timestamps */
  timestamp (1);

  /* Make immortal (disable death timer) */
  lifetime (0) ;

  /* Wait for requests */
  idle () ;
}

list MESSAGE_HANDLER()
{
  on_message return MESSAGE_HANDLER() ;
  return "$ACK" ;
} ;
on_message return MESSAGE_HANDLER() ;

list SENDMAIL()
{
  /* Required tokens and values:
   *
   * SUBJECT
   * DISTRIBUTION
   * TEXT
   *
   */

  if ( !exists ( SUBJECT ) || !count ( SUBJECT ) ||
       !exists ( DISTRIBUTION ) || !count ( DISTRIBUTION ) ||
       !exists ( TEXT ) || !count ( TEXT ) )
    return { "%SENDMAIL: Invalid args ", args } ;

  mailfile = "autolog:"+self(2)+".txt" ;
  h = fopen( mailfile, "w");
  if ( h ) {
    fputs ( TEXT, h );
    fclose h ;
    str cmd = {"mail ",mailfile,
                " /subject=\"",SUBJECT,"\"",
                " \"@AUTORUN:",DISTRIBUTION,"\"" } ;
    system ( cmd ); 
  }
  return "$ACK" ;
};

list GET_EQPID_STATUS()
{
  /* Required tokens and values:
   *
   *   EQPID
   *
   * Reply Tokens:
   *   EQPTYPE  - optional
   *   LOCATION - optional
   *   STATUS   - PROMIS equipment status
   */

  /* *****************************************************************
   *                         INITIALIZE
   *******************************************************************/
  /* Check arguments */
  if ( !exists ( EQPID ) || !count ( EQPID ) )
    return DONE_GET_EQPID_STATUS ({ "%PROMIS: Invalid args ", args } ) ;

  /* *****************************************************************
   *                   PERFORM EQUIPMENT STATUS
   *******************************************************************/
  EQPID = toupper trim EQPID ;
  pclose("eqps");
  ret = pget("eqps.eqpskey","ge",EQPID) ;
  if ( !ret || 
       trim eqps.eqpid != EQPID ||
       eqps.rectype != "C" )
    return DONE_GET_EQPID_STATUS ( { "%PROMIS: no such equipment: ",EQPID });
   
  EQPTYPE = trim eqps.eqptyp ;

  pclose "tbls" ;
  puts {"...getting EQUN record for ",eqps.eqpid } ;
  ret = pget ( "tbls.tblskey", "eq", "EQUN" + trim(eqps.eqpid) ) ;
  if ( !ret ) return DONE_GET_EQPID_STATUS ( { "%PROMIS: no such equipment: ",EQPID });
  tbls.tablename ;
  LOCATION = trim equn.locationid ;

  if ( !exists ( COMMENTS ) )
    return DONE_GET_EQPID_STATUS ( trim eqps.status ) ;
  
  list COMMENTS = eqps.eqpscomment ;
  int COMMENTCOUNT = eqps.commentcount ;
  if ( COMMENTCOUNT == 0 ) COMMENTCOUNT = 1 ;
  str COMMENTS[COMMENTCOUNT] ; 

  return DONE_GET_EQPID_STATUS ( trim eqps.status ) ;
};

list DONE_GET_EQPID_STATUS( str TEXT )
{
  puts TEXT ;
  EXIT_FUNCTION() ;
  QUIT_FUNCTION() ;
  if ( exists EQPID ) undef EQPID ;
  /*
  if ( exists LOCATION ) undef LOCATION ;
  if ( exists EQPTYPE ) undef EQPTYPE ;
  if ( exists COMMENTS ) undef COMMENTS ;
  */
  return TEXT ;
};

list GET_FILE_FIELDS()
{
  /* Required tokens and values:
   *
   *   FILE
   *   KEYNAME
   *   KEYVALUE
   *
   * Reply Tokens:
   *   <fieldname> - optional
   */

  /* *****************************************************************
   *                         INITIALIZE
   *******************************************************************/
  /* Check arguments */
  if ( !exists (FILE)     || count (FILE) == 0 ||
       !exists (KEYNAME)  || count (KEYNAME) == 0 ||
       !exists (KEYVALUE) || count (KEYVALUE) == 0 ) {

    /* Bad arguments */
    return DONE_GET_FILE_FIELDS ( {"%ARGS: Invalid arguments supplied"} ) ; 
  }

  str promis_file = trim tolower FILE ;
  ret = popen promis_file ;

  if ( !ret ) return DONE_GET_FILE_FIELDS ( 
        {"%FILE: Could not open PROMIS file ",promis_file});

  str promis_key = promis_file + "." + tolower KEYNAME ;

  str promis_key_value = trim pack str KEYVALUE ;

  ret = pget ( promis_key, "eq", promis_key_value ) ;
  if ( !ret )  return DONE_GET_FILE_FIELDS ( 
        {"Could not get key ",promis_key," for value ",promis_key_value});

  n = count args ;
  for ( i=0; i<n; i++ ) {

    str fieldname = args[i] ;

    if ( count (*fieldname) == 0 ) {

      str promis_field = promis_file + "." + trim tolower fieldname ;

      if ( exists ( *promis_field ) ) {
        *fieldname = trim *promis_field ;
      }
    }
  }

   return DONE_GET_FILE_FIELDS("$ACK") ;
} ;


list DONE_GET_FILE_FIELDS( str TEXT )
{
  puts TEXT ;
  EXIT_FUNCTION() ;
  QUIT_FUNCTION() ;
  undef FILE ;
  undef KEYNAME ;
  undef KEYVALUE ;
  return TEXT ;
};


EXIT_FUNCTION()
{
  pexec("EXIT") ;
}

QUIT_FUNCTION()
{
  pexec("QUIT") ;
}  

MESSAGE() { return ; }

ABORT() { exit(); }

DISCONNECT() { exit(); }

! The CONNECT method must be enabled after the program loads.
enable CONNECT ;
! Begin the HyperScript program.  
CONNECT();
!
! If we get here, then there's either an error in the Hyperscript or the
! HyperScript has called the exit() function. At this point, we are
! back executing a normal PROMIS script, and so we should exit MUCHMAIN
QUIT RETURN
